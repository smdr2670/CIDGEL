.TH "binomial.h" 3 "Thu Jul 31 2014" "Version 1.0" "CIDGEL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
binomial.h \- 
.PP
header file for binomal type and main operations on binomials  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBbin_tag\fP"
.br
.RI "\fIA structure to represent binomials\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBring_putvar\fP(ofile, v)   fprintf(ofile,'%c','a'+v)"
.br
.ti -1c
.RI "#define \fBBINOMIAL\fP   1"
.br
.ti -1c
.RI "#define \fBMONOMIAL\fP   0"
.br
.ti -1c
.RI "#define \fBFACET\fP   0"
.br
.ti -1c
.RI "#define \fBNONFACET\fP   1"
.br
.ti -1c
.RI "#define \fBUNKNOWN\fP   -1"
.br
.ti -1c
.RI "#define \fBbinomial_next\fP(b)   (b->next)"
.br
.ti -1c
.RI "#define \fBbinomial_lead\fP(b)   (b->exps1)"
.br
.ti -1c
.RI "#define \fBbinomial_trail\fP(b)   (b->exps2)"
.br
.ti -1c
.RI "#define \fBmonomial_set\fP(b)   (b->bf=\fBMONOMIAL\fP)"
.br
.ti -1c
.RI "#define \fBbinomial_set\fP(b)   (b->bf=\fBBINOMIAL\fP)"
.br
.ti -1c
.RI "#define \fBbinomial_facet\fP(b)   (b->ff)"
.br
.ti -1c
.RI "#define \fBbinomial_lexordered\fP(b)   ((\fBmonomial_lexcomp\fP(\fBbinomial_lead\fP(b),\fBbinomial_trail\fP(b))>=0) ? \fBTRUE\fP : \fBFALSE\fP)"
.br
.ti -1c
.RI "#define \fBbinomial_grlexordered\fP(b)   ((\fBmonomial_grlexcomp\fP(\fBbinomial_lead\fP(b),\fBbinomial_trail\fP(b))>=0) ? \fBTRUE\fP : \fBFALSE\fP)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int * \fBmonomial\fP"
.br
.ti -1c
.RI "typedef struct \fBbin_tag\fP * \fBbinomial\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcode_dim_set\fP (int n)"
.br
.ti -1c
.RI "int \fBring_set\fP (int n)"
.br
.RI "\fISets the ring_N\&. \fP"
.ti -1c
.RI "int \fBring_getvar\fP (FILE *\fBinfile\fP)"
.br
.RI "\fIReads the variable of the inputfile\&. \fP"
.ti -1c
.RI "int \fBmonomial_divides\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if m1 divides m2\&. \fP"
.ti -1c
.RI "int \fBmonomial_equal\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if monomials m1 and m2 have same exponents\&. \fP"
.ti -1c
.RI "int \fBmonomial_lexcomp\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if m1 is lexicographically greater then m2\&. \fP"
.ti -1c
.RI "int \fBmonomial_rlexcomp\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if m1 is degree reverse lexicographically greater than m2 with variables taken in order a>b>\&.\&.\&., except that variable ring_lv is taken last (if it is >=0)\&. \fP"
.ti -1c
.RI "int \fBmonomial_grlexcomp\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if m1 is degree lexicographically greater than m2\&. \fP"
.ti -1c
.RI "int \fBmonomial_rel_prime\fP (\fBmonomial\fP m1, \fBmonomial\fP m2)"
.br
.RI "\fIDetermines if m1 is reletively prime to m2\&. \fP"
.ti -1c
.RI "void \fBprint_monomial\fP (FILE *of, int *exps)"
.br
.RI "\fIPrints monomial in a file\&. \fP"
.ti -1c
.RI "void \fBget_monomial\fP (FILE *is, int *exps)"
.br
.RI "\fIReads ascii representation of monomial as power product onvert to exponent vector stored in *exps\&. \fP"
.ti -1c
.RI "void \fBmonomial_lcm\fP (\fBmonomial\fP m1, \fBmonomial\fP m2, \fBmonomial\fP m3)"
.br
.RI "\fImonomial_lcm copy least common multiple of m1 and m2 into m3\&. \fP"
.ti -1c
.RI "int \fBmonomial_stddegree\fP (\fBmonomial\fP m)"
.br
.RI "\fIDetermines the degree of a monomial\&. \fP"
.ti -1c
.RI "\fBbinomial\fP \fBbinomial_new\fP ()"
.br
.RI "\fIAllocate space for a new binomial\&. Initializes flags and set exponents to zero\&. \fP"
.ti -1c
.RI "int \fBring_read\fP (FILE *\fBinfile\fP)"
.br
.RI "\fIReads the number of variables out of a file and sets the ring dimension\&. \fP"
.ti -1c
.RI "void \fBbinomial_free\fP (\fBbinomial\fP m)"
.br
.RI "\fIReclaims space allocated by \fBbinomial_new()\fP\&. \fP"
.ti -1c
.RI "void \fBbinomial_read\fP (FILE *is, \fBbinomial\fP b)"
.br
.RI "\fIReads file and stores a binomial\&. \fP"
.ti -1c
.RI "void \fBbinomial_print\fP (FILE *of, \fBbinomial\fP b)"
.br
.RI "\fIPrints the binomial\&. \fP"
.ti -1c
.RI "\fBbinomial\fP \fBmonomial_spair\fP (\fBbinomial\fP b, \fBmonomial\fP m)"
.br
.RI "\fIForms S-Pair between marked binomial and marked monomial and reduce result by binomial as many times as possible\&. \fP"
.ti -1c
.RI "void \fBbinomial_flip\fP (\fBbinomial\fP b)"
.br
.RI "\fIInterchange leading and trailing terms of a binomial\&. \fP"
.ti -1c
.RI "int \fBbinomial_spair\fP (\fBbinomial\fP b1, \fBbinomial\fP b2)"
.br
.RI "\fIReplaces b1, by spair of b1 and b2 -- the spair is taken with respect to the markings of b1 and b2, but it's marking is not meaningfull\&. \fP"
.ti -1c
.RI "int \fBbinomial_first_term_degree\fP (\fBbinomial\fP b)"
.br
.RI "\fICalculates the degree of the first term\&. \fP"
.ti -1c
.RI "int \fBbinomial_degree_compatible\fP (\fBbinomial\fP b)"
.br
.RI "\fIReturns whether a binomial is degree compatible or not\&. \fP"
.ti -1c
.RI "void \fBbinomial_copy\fP (\fBbinomial\fP src, \fBbinomial\fP dest)"
.br
.RI "\fICopies source binomials exponents and flags to those of the destination binomials\&. \fP"
.ti -1c
.RI "int \fBbinomial_variable_position\fP (\fBbinomial\fP b)"
.br
.RI "\fIReturns the position which will NOT belong to the non-prime ideal\&. Note that the function is only called when the leading term of the binomial has the degree 1\&. \fP"
.ti -1c
.RI "void \fBreducetrail\fP (\fBbinomial\fP b1, \fBbinomial\fP b2)"
.br
.RI "\fIAssuming that lead(b2) divides trail(b1) change b1 into binomial resulting from bumping b2 so that lead(b2)=trail(b1) and adding result to b1\&. \fP"
.ti -1c
.RI "void \fBbinomial_bumpto\fP (\fBbinomial\fP b1, \fBbinomial\fP b2)"
.br
.RI "\fIAssuming that the leading term of b1 divides that of b2 multiply both sides of b1 so that the leading terms of b1 and b2 are equal\&. \fP"
.ti -1c
.RI "int \fBbinomial_compair\fP (\fBbinomial\fP b1, \fBbinomial\fP b2)"
.br
.RI "\fIDetermines if the lead term of b1 is lexicographically greater than that of b2 or if they tie return true if the trail term b1 is greater or equal to that of b2 otherwise return false\&. \fP"
.ti -1c
.RI "void \fBbinomial_puncture\fP (\fBbinomial\fP b, int position)"
.br
.RI "\fIPunctures the binomial with cancelling a certain variable\&. \fP"
.ti -1c
.RI "int \fBbinomial_equal\fP (\fBbinomial\fP b1, \fBbinomial\fP b2)"
.br
.RI "\fIChecks if two binomials are identical\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBring_N\fP"
.br
.ti -1c
.RI "int \fBring_lv\fP"
.br
.ti -1c
.RI "int * \fBring_weight\fP"
.br
.ti -1c
.RI "int \fBcode_dim\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
header file for binomal type and main operations on binomials 

This file is reused from TiGERS, Toric Groebner Basis Enumeration by Reverse Search copyright (c) 1999 Birk Huber
.PP
\fBAuthor:\fP
.RS 4
Birk Huber, 4/99 
.PP
Daniel Rembold 
.RE
.PP
\fBBug\fP
.RS 4
No known bugs
.RE
.PP

.PP
Definition in file \fBbinomial\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define BINOMIAL   1"

.PP
Definition at line 139 of file binomial\&.h\&.
.SS "#define binomial_facet(b)   (b->ff)"

.PP
Definition at line 150 of file binomial\&.h\&.
.SS "#define binomial_grlexordered(b)   ((\fBmonomial_grlexcomp\fP(\fBbinomial_lead\fP(b),\fBbinomial_trail\fP(b))>=0) ? \fBTRUE\fP : \fBFALSE\fP)"

.PP
Definition at line 326 of file binomial\&.h\&.
.SS "#define binomial_lead(b)   (b->exps1)"

.PP
Definition at line 146 of file binomial\&.h\&.
.SS "#define binomial_lexordered(b)   ((\fBmonomial_lexcomp\fP(\fBbinomial_lead\fP(b),\fBbinomial_trail\fP(b))>=0) ? \fBTRUE\fP : \fBFALSE\fP)"

.PP
Definition at line 319 of file binomial\&.h\&.
.SS "#define binomial_next(b)   (b->next)"

.PP
Definition at line 145 of file binomial\&.h\&.
.SS "#define binomial_set(b)   (b->bf=\fBBINOMIAL\fP)"

.PP
Definition at line 149 of file binomial\&.h\&.
.SS "#define binomial_trail(b)   (b->exps2)"

.PP
Definition at line 147 of file binomial\&.h\&.
.SS "#define FACET   0"

.PP
Definition at line 141 of file binomial\&.h\&.
.SS "#define MONOMIAL   0"

.PP
Definition at line 140 of file binomial\&.h\&.
.SS "#define monomial_set(b)   (b->bf=\fBMONOMIAL\fP)"

.PP
Definition at line 148 of file binomial\&.h\&.
.SS "#define NONFACET   1"

.PP
Definition at line 142 of file binomial\&.h\&.
.SS "#define ring_putvar(ofile, v)   fprintf(ofile,'%c','a'+v)"

.PP
Definition at line 27 of file binomial\&.h\&.
.SS "#define UNKNOWN   -1"

.PP
Definition at line 143 of file binomial\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBbin_tag\fP* \fBbinomial\fP"

.PP
Definition at line 124 of file binomial\&.h\&.
.SS "typedef int* \fBmonomial\fP"

.PP
Definition at line 30 of file binomial\&.h\&.
.SH "Function Documentation"
.PP 
.SS "void binomial_bumpto (\fBbinomial\fPb1, \fBbinomial\fPb2)"

.PP
Assuming that the leading term of b1 divides that of b2 multiply both sides of b1 so that the leading terms of b1 and b2 are equal\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb1\fP The first binomial\&. 
.br
\fIb2\fP The second binomial\&. 
.RE
.PP

.PP
Definition at line 457 of file binomial\&.c\&.
.SS "int binomial_compair (\fBbinomial\fPb1, \fBbinomial\fPb2)"

.PP
Determines if the lead term of b1 is lexicographically greater than that of b2 or if they tie return true if the trail term b1 is greater or equal to that of b2 otherwise return false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb1\fP The first binomial\&. 
.br
\fIb2\fP The second binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) or FALSE (=1)\&. 
.RE
.PP

.PP
Definition at line 477 of file binomial\&.c\&.
.SS "void binomial_copy (\fBbinomial\fPsrc, \fBbinomial\fPdest)"

.PP
Copies source binomials exponents and flags to those of the destination binomials\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP Source binomial\&. 
.br
\fIdest\fP Destination binomial\&. 
.RE
.PP

.PP
Definition at line 384 of file binomial\&.c\&.
.SS "int binomial_degree_compatible (\fBbinomial\fPb)"

.PP
Returns whether a binomial is degree compatible or not\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP The given binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if first term has a higher degree, 0 if degrees are equal, -1 if second term has a higher degree\&. 
.RE
.PP

.PP
Definition at line 520 of file binomial\&.c\&.
.SS "int binomial_equal (\fBbinomial\fPb1, \fBbinomial\fPb2)"

.PP
Checks if two binomials are identical\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb1\fP First binomial\&. 
.br
\fIb2\fP Second binomial\&. 
.RE
.PP

.PP
Definition at line 544 of file binomial\&.c\&.
.SS "int binomial_first_term_degree (\fBbinomial\fPb)"

.PP
Calculates the degree of the first term\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP The given binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Degree of first term\&. 
.RE
.PP

.PP
Definition at line 491 of file binomial\&.c\&.
.SS "void binomial_flip (\fBbinomial\fPb)"

.PP
Interchange leading and trailing terms of a binomial\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP Binomial which will be flipped\&. 
.RE
.PP

.PP
Definition at line 396 of file binomial\&.c\&.
.SS "void binomial_free (\fBbinomial\fPm)"

.PP
Reclaims space allocated by \fBbinomial_new()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP Binomial which shall be deleted\&. 
.RE
.PP

.PP
Definition at line 315 of file binomial\&.c\&.
.SS "\fBbinomial\fP binomial_new ()"

.PP
Allocate space for a new binomial\&. Initializes flags and set exponents to zero\&. 
.PP
\fBReturns:\fP
.RS 4
New allocated binomial\&. 
.RE
.PP

.PP
Definition at line 290 of file binomial\&.c\&.
.SS "void binomial_print (FILE *of, \fBbinomial\fPb)"

.PP
Prints the binomial\&. 
.PP
\fBParameters:\fP
.RS 4
\fIof\fP The output stream\&. 
.br
\fIb\fP Binomial which shall be printed\&. 
.RE
.PP

.PP
Definition at line 364 of file binomial\&.c\&.
.SS "void binomial_puncture (\fBbinomial\fPb, intposition)"

.PP
Punctures the binomial with cancelling a certain variable\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP The binomial to be punctured\&. 
.br
\fIposition\fP Position of the exp\&. vector which will be set to zero\&. 
.RE
.PP

.PP
Definition at line 537 of file binomial\&.c\&.
.SS "void binomial_read (FILE *is, \fBbinomial\fPb)"

.PP
Reads file and stores a binomial\&. 
.PP
\fBParameters:\fP
.RS 4
\fIis\fP The input file stream\&. 
.br
\fIb\fP Read binomial will be stored in this parameter\&. 
.RE
.PP

.PP
Definition at line 323 of file binomial\&.c\&.
.SS "int binomial_spair (\fBbinomial\fPb1, \fBbinomial\fPb2)"

.PP
Replaces b1, by spair of b1 and b2 -- the spair is taken with respect to the markings of b1 and b2, but it's marking is not meaningfull\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb1\fP The first binomial\&. 
.br
\fIb2\fP The second binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) if result is equivalent to zero monomial\&. 
.RE
.PP

.PP
Definition at line 432 of file binomial\&.c\&.
.SS "int binomial_variable_position (\fBbinomial\fPb)"

.PP
Returns the position which will NOT belong to the non-prime ideal\&. Note that the function is only called when the leading term of the binomial has the degree 1\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP The given binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Index i of exponent vector with i != 0\&. 
.RE
.PP

.PP
Definition at line 502 of file binomial\&.c\&.
.SS "void code_dim_set (intn)"

.PP
Definition at line 62 of file binomial\&.c\&.
.SS "void get_monomial (FILE *is, int *exps)"

.PP
Reads ascii representation of monomial as power product onvert to exponent vector stored in *exps\&. 
.PP
\fBParameters:\fP
.RS 4
\fIis\fP The input stream\&. 
.br
\fIexps\fP Store the exponent vector in exps\&.s 
.RE
.PP

.PP
Definition at line 136 of file binomial\&.c\&.
.SS "int monomial_divides (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if m1 divides m2\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP First monomial\&. 
.br
\fIm2\fP Second monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) or FALSE(=1)\&. 
.RE
.PP

.PP
Definition at line 160 of file binomial\&.c\&.
.SS "int monomial_equal (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if monomials m1 and m2 have same exponents\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP First monomial\&. 
.br
\fIm2\fP Second monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) or FALSE(=1)\&. 
.RE
.PP

.PP
Definition at line 183 of file binomial\&.c\&.
.SS "int monomial_grlexcomp (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if m1 is degree lexicographically greater than m2\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP The first monomial\&. 
.br
\fIm2\fP The second monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>0 if m1 is degree lexicographically greater than m2\&. 
.RE
.PP

.PP
Definition at line 254 of file binomial\&.c\&.
.SS "void monomial_lcm (\fBmonomial\fPm1, \fBmonomial\fPm2, \fBmonomial\fPm3)"

.PP
monomial_lcm copy least common multiple of m1 and m2 into m3\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP first monomial 
.br
\fIm2\fP second monomial 
.br
\fIm3\fP lcm monomial 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 194 of file binomial\&.c\&.
.SS "int monomial_lexcomp (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if m1 is lexicographically greater then m2\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP The first monomial\&. 
.br
\fIm2\fP The second monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>0 if m1 is lexicographically greater then m2\&. 
.RE
.PP

.PP
Definition at line 217 of file binomial\&.c\&.
.SS "int monomial_rel_prime (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if m1 is reletively prime to m2\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP First monomial\&. 
.br
\fIm2\fP Second monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) or FALSE(=1)\&. 
.RE
.PP

.PP
Definition at line 172 of file binomial\&.c\&.
.SS "int monomial_rlexcomp (\fBmonomial\fPm1, \fBmonomial\fPm2)"

.PP
Determines if m1 is degree reverse lexicographically greater than m2 with variables taken in order a>b>\&.\&.\&., except that variable ring_lv is taken last (if it is >=0)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm1\fP The first monomial\&. 
.br
\fIm2\fP The second binomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
>0 if m1 is degree reverse lexicographically greater than m2\&. 
.RE
.PP

.PP
Definition at line 228 of file binomial\&.c\&.
.SS "\fBbinomial\fP monomial_spair (\fBbinomial\fPb, \fBmonomial\fPm)"

.PP
Forms S-Pair between marked binomial and marked monomial and reduce result by binomial as many times as possible\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP First binomial\&. 
.br
\fIm\fP The Mononomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
S-Pair between the parameters\&. 
.RE
.PP

.PP
Definition at line 404 of file binomial\&.c\&.
.SS "int monomial_stddegree (\fBmonomial\fPm)"

.PP
Determines the degree of a monomial\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP The monomial\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The degree as an integer\&. 
.RE
.PP

.PP
Definition at line 206 of file binomial\&.c\&.
.SS "void print_monomial (FILE *of, int *exps)"

.PP
Prints monomial in a file\&. 
.PP
\fBParameters:\fP
.RS 4
\fIof\fP Outputfile where monomial will be printed\&. 
.br
\fIexps\fP Vector which contains the exponents\&. 
.RE
.PP

.PP
Definition at line 116 of file binomial\&.c\&.
.SS "void reducetrail (\fBbinomial\fPb1, \fBbinomial\fPb2)"

.PP
Assuming that lead(b2) divides trail(b1) change b1 into binomial resulting from bumping b2 so that lead(b2)=trail(b1) and adding result to b1\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb1\fP The first binomial\&. 
.br
\fIb2\fP The second binomial\&. 
.RE
.PP

.PP
Definition at line 467 of file binomial\&.c\&.
.SS "int ring_getvar (FILE *infile)"

.PP
Reads the variable of the inputfile\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinfile\fP File/Stream consisting the variables\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
ASCII code of the variable\&. 
.RE
.PP

.PP
Definition at line 97 of file binomial\&.c\&.
.SS "int ring_read (FILE *infile)"

.PP
Reads the number of variables out of a file and sets the ring dimension\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinfile\fP File/Stream consisting the number of dimensions\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) if function was successfull\&. 
.RE
.PP

.PP
Definition at line 86 of file binomial\&.c\&.
.SS "int ring_set (intn)"

.PP
Sets the ring_N\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of Dimensions\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE(=0) if function was successfull\&. 
.RE
.PP

.PP
Definition at line 70 of file binomial\&.c\&.
.SH "Variable Documentation"
.PP 
.SS "int code_dim"

.PP
Definition at line 60 of file binomial\&.c\&.
.SS "int ring_lv"

.PP
Definition at line 58 of file binomial\&.c\&.
.SS "int ring_N"

.PP
Definition at line 57 of file binomial\&.c\&.
.SS "int* ring_weight"

.PP
Definition at line 59 of file binomial\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for CIDGEL from the source code\&.
